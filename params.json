{"name":"DynamicEnvVar","body":"## Introduction\r\n\r\nIn many situations, it’s necessary to set application specific environment variables for testing and debugging purposes. These kind of variables are exclusive to the application and will be dead when the application exits. For example, suppose if you've a rendering application in which the rendering path is specified as environment variable. Sometimes it might be necessary to change these variables for testing or in some situations you may need to add or delete the existing one. In most cases, the application specific variables are controlled launching through script files after setting up necessary variables or by a launcher application (Environment variables are inherited from Parent Process). Still dynamically updating variables is out of our reach.\r\n\r\nIn this article, I'm introducing a simple tool to dynamically set environment strings to any process in the system. This tool won't modify any settings of the system or user environment variables. Instead it adds/updates a particular process’s environment variables.\r\n\r\nThis tool supports the following operations:\r\n\r\n* Add a new variable\r\n* Replace existing variable\r\n* Append to existing variable (separated by “;”)\r\n* Deleting a variable\r\n\r\n## How Do I?\r\n\r\nTo Add/Replace a variable, just select a process or enter a valid process ID in the corresponding text boxes. Then press “Set” button. If it’s required to add to an existing variable, please check “Add to existing”. To delete a variable, enter a valid variable name and leave the value text box as empty. Make sure that you've unchecked the “Add to existing” check box. Under the hood OK let’s see how I accomplished this. It’s simple as follows:\r\n\r\n## Create a shared memory with user entered content and options\r\nInject our own DLL to the target process\r\nIn the DLL main, open the share memory and read the required data and finally set the variable\r\nReturn from DLL\r\nNow the DLL is not necessary to remain in the process, eject it.\r\n\r\n## Why Injecting?\r\n\r\nWindows provided APIs will work with the current process. These APIs can't work with a foreign process. If a DLL is injected to a particular process, further code will be executed in the context of that particular process.\r\n\r\n## How to Inject a DLL?\r\n\r\nThere are several methods to inject a DLL. Please see Windows via C/C++ (or its previous version) to know more about different DLL injection methods. Here in this program, I've used Remote threads. I hope the following code can explain better than words. Anyway the basic technique is to set LoadLibrary as thread routine to load the DLL in remote process. The name of the DLL file must be accessible from the target process itself. For that, we've to use virtual memory APIs. See the code.\r\n\r\n```CPP\r\n// Function to inject the library\r\nvoid CDLLInjector::InjectLibW( DWORD dwProcessId )\r\n{\r\n\tHANDLE hProcess= NULL; // Process handle\r\n\tPWSTR pszLibFileRemote = NULL;\r\n\tHANDLE hRemoteThread = NULL; \r\n\t__try\r\n\t{\r\n\t\thProcess = OpenProcess(\r\n\t\t\tPROCESS_QUERY_INFORMATION |   \r\n\t\t\tPROCESS_CREATE_THREAD     | \r\n\t\t\tPROCESS_VM_OPERATION |\r\n\t\t\tPROCESS_VM_WRITE,  // For CreateRemoteThread\r\n\t\t\tFALSE, dwProcessId);\r\n\r\n\t\tif( !hProcess )\r\n\t\t{\r\n\t\t\tAfxMessageBox( _T(\"Failed to update selected process\") );\r\n\t\t\t__leave;\r\n\t\t}\r\n\r\n\t\tWCHAR szFilePath[MAX_PATH];\r\n\t\tGetModuleFileNameW( NULL, szFilePath, MAX_PATH );\r\n\r\n\t\t// Remove file name of the string\r\n\t\tPathRemoveFileSpecW( szFilePath );\r\n\r\n\t\t// Append the DLL file which is there in the same directory of exe\r\n\t\tLPCWSTR pszLib = L\"\\\\SetEnvLib.dll\";\r\n\r\n\t\t// Append the string\r\n\t\twcscat_s( szFilePath, MAX_PATH, pszLib ); \r\n\r\n\t\tint cch = 1 + lstrlenW(szFilePath);\r\n\t\tint cb  = cch * sizeof(WCHAR);\r\n\r\n\t\t// Allocate space in the remote process for the pathname\r\n\t\tpszLibFileRemote = (PWSTR) VirtualAllocEx( hProcess, \r\n\t\t\tNULL, cb, \r\n\t\t\tMEM_COMMIT, PAGE_READWRITE);\r\n\t\tif ( pszLibFileRemote == NULL) \r\n\t\t{\r\n\t\t\tAfxMessageBox( _T(\"Unable to allocate memory\") );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Copy the DLL's pathname to the remote process' address space\r\n\t\tif (!WriteProcessMemory(hProcess, pszLibFileRemote,\r\n\t\t\t(PVOID) szFilePath, cb, NULL)) \r\n\t\t{\r\n\t\t\tAfxMessageBox( _T( \"Failed to write\" ));\r\n\t\t\treturn;\r\n\t\t};\r\n\r\n\t\t// Create remote thread and inject the library\r\n\t\thRemoteThread = CreateRemoteThread( hProcess, NULL, 0, \r\n\t\t\t(LPTHREAD_START_ROUTINE)LoadLibraryW, \r\n\t\t\tpszLibFileRemote, NULL,NULL );\r\n\r\n\t\tif( !hRemoteThread )\r\n\t\t{\r\n\t\t\tAfxMessageBox( _T(\"Failed to update selected process\") );\r\n\t\t\t__leave;\r\n\t\t}\r\n\r\n\t\tWaitForSingleObject( hRemoteThread, INFINITE );\r\n\r\n\t\tAfxMessageBox( _T(\"Successfully Set values\"));\r\n\t}\r\n\t__finally // Do the cleanup\r\n\t{\r\n\t\t// Free the remote memory that contained the DLL's pathname\r\n\t\tif (pszLibFileRemote != NULL) \r\n\t\t\tVirtualFreeEx(hProcess, pszLibFileRemote, 0, MEM_RELEASE);\r\n\r\n\t\tif ( hRemoteThread != NULL) \r\n\t\t\tCloseHandle(hRemoteThread);\r\n\r\n\t\tif ( hProcess != NULL) \r\n\t\t\tCloseHandle(hProcess);\r\n\t}\r\n}\r\n```\r\n\r\n## How to Eject an Injected DLL?\r\n\r\nOnce you have completed the task, it’s not good to make our DLL as a burden to the target process. Again we unload the library in the same way we loaded it. Create Remote thread with FreeLibrary API and pass the module base address of SetEnvVarLIb.dll. For this, we can use Toolhelp library APIs. If we create the module handle snapshot of the target process, it’d be able to get the base of address of our injected DLL. See the code below for more details:\r\n\r\n```CPP\r\n// Eject the library loaded to remote process\r\nBOOL CDLLInjector::EjectLibW( DWORD dwProcessID )\r\n{\r\n\tBOOL bOk\t\t   = FALSE; // Assume that the function fails\r\n\tHANDLE hthSnapshot = NULL;\r\n\tHANDLE hProcess = NULL, hThread = NULL;\r\n\r\n\t__try\r\n\t{\r\n\t\t// Grab a new snapshot of the process\r\n\t\ththSnapshot = CreateToolhelp32Snapshot\r\n\t\t\t\t(TH32CS_SNAPMODULE, dwProcessID );\r\n\t\tif (hthSnapshot == INVALID_HANDLE_VALUE) __leave;\r\n\r\n\t\t// Get the HMODULE of the desired library\r\n\t\tMODULEENTRY32W me = { sizeof(me) };\r\n\t\tBOOL bFound = FALSE;\r\n\t\tBOOL bMoreMods = Module32FirstW(hthSnapshot, &me);\r\n\r\n\t\t// Iterate through all the loaded modules\r\n\t\tfor (; bMoreMods; bMoreMods = Module32NextW(hthSnapshot, &me))\r\n\t\t{\r\n\t\t\tbFound = (_wcsicmp(me.szModule,  L\"SetEnvLib.dll\" ) == 0) || \r\n\t\t\t\t(_wcsicmp(me.szExePath, L\"SetEnvLib.dll\" ) == 0);\r\n\t\t\tif (bFound) break;\r\n\t\t}\r\n\t\tif (!bFound) __leave;\r\n\r\n\t\t// Get a handle for the target process.\r\n\t\thProcess = OpenProcess(\r\n\t\t\tPROCESS_QUERY_INFORMATION |   \r\n\t\t\tPROCESS_CREATE_THREAD     | \r\n\t\t\tPROCESS_VM_OPERATION,  // For CreateRemoteThread\r\n\t\t\tFALSE, dwProcessID);\r\n\t\tif (hProcess == NULL) __leave;\r\n\r\n\t\t// Get the address of FreeLibrary in Kernel32.dll\r\n\t\tPTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)\r\n\t\t\tGetProcAddress\r\n\t\t\t(GetModuleHandle(TEXT(\"Kernel32\")), \"FreeLibrary\");\r\n\t\tif (pfnThreadRtn == NULL) __leave;\r\n\r\n\t\t// Create a remote thread that calls FreeLibrary()\r\n\t\thThread = CreateRemoteThread(hProcess, NULL, 0, \r\n\t\t\tpfnThreadRtn, me.modBaseAddr, 0, NULL);\r\n\t\tif (hThread == NULL) __leave;\r\n\r\n\t\t// Wait for the remote thread to terminate\r\n\t\tWaitForSingleObject(hThread, INFINITE);\r\n\r\n\t\tbOk = TRUE; // Everything executed successfully\r\n\t}\r\n\t__finally \r\n\t{\r\n\t\tif (hthSnapshot != NULL) \r\n\t\t\tCloseHandle(hthSnapshot);\r\n\r\n\t\tif (hThread     != NULL) \r\n\t\t\tCloseHandle(hThread);\r\n\r\n\t\tif (hProcess    != NULL) \r\n\t\t\tCloseHandle(hProcess);\r\n\t}\r\n\r\n\treturn bOk;\r\n}\r\n```\r\n\r\n## Preparing the Shared Memory before Inject\r\nOK now you learned about the basics of Injecting and Ejecting. Before injecting the code, we have to prepare the data in a shared memory. In our case, we’ve 3 things to share to the DLL.\r\n\r\n* Variable\r\n* Value\r\n* Flag to specify add to existing or not\r\n\r\nThe following structure will help us to hold the required information:\r\n\r\n```ruby\r\n// Structure to share data\r\n#pragma pack( push )\r\n#pragma pack( 4 )\r\nstruct SharedData\r\n{\r\n\tBOOL bAddToExisting;\r\n\tWCHAR strVariable[1024];\r\n\tWCHAR strValue[1024];\r\n\r\n\tSharedData()\r\n\t{\r\n\t\tZeroMemory( strVariable, sizeof( strVariable ));\r\n\t\tZeroMemory( strValue, sizeof( strValue ));\r\n\t\tbAddToExisting = TRUE;\r\n\t}\r\n};\r\n```\r\n\r\nTo keep the size of structure the same in both DLL and our injecting application, we’ve set the packing values explicitly. Otherwise it might be affected with the project settings or pragma pack pre-processor. Now create and write the data to shared memory. To keep it uniform, we’re always dealing with UNICODE character set. The CDLLInjector::SetEnvironmentVariable function accepts CString values which define the character set according to the project settings. Internally the function converts ANSI string to UNICODE if the project’s settings is not UNICODE and calls the UNICODE functions which does the actual task.\r\n\r\n```CPP\r\n// Update the user entered data to sharememory\r\nBOOL CDLLInjector::CreateAndCopyToShareMem\r\n\t( LPCWSTR lpVarName, LPCWSTR lpVarVal, BOOL bAddToExisting )\r\n{\r\n\tSharedData stData;\r\n\r\n\tint nLenVar = wcslen( lpVarName );\r\n\tif ( 0 == nLenVar || nLenVar >= _countof( stData.strVariable ))\r\n\t{\r\n\t\tAfxMessageBox( _T(\"Variable length is too high. \r\n\t\t\t\tCurrently supports only 1024 chars\" ));\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tLPWSTR pBuf;\r\n\r\n\t// prepare data for copying \r\n\twcscpy_s( stData.strVariable, _countof( stData.strVariable), lpVarName );\r\n\twcscpy_s( stData.strValue, _countof( stData.strValue), lpVarVal );\r\n\tstData.bAddToExisting = bAddToExisting;\r\n\r\n\tm_hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, \r\n\t\t\t\tPAGE_READWRITE, 0, sizeof(stData),\r\n\t\t\t\tSHAREMEM_NAME );\r\n\r\n\tif ( m_hMapFile == NULL) \r\n\t{ \r\n\t\tMessageBox(0, _T(\"Could not create file mapping object\"), \r\n\t\t\t_T(\"Error\"), MB_OK | MB_ICONERROR );\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tpBuf = (LPWSTR) MapViewOfFile( m_hMapFile, FILE_MAP_ALL_ACCESS, \r\n\t\t\t\t0, 0, sizeof( stData ));\r\n\r\n\tif ( pBuf == NULL) \r\n\t{ \r\n\t\tMessageBox(0, _T(\"Could not map view of file\"), \r\n\t\t\t_T( \"Error\" ), MB_OK | MB_ICONERROR ); \r\n\r\n\t\tCloseHandle(m_hMapFile);\r\n\t\tm_hMapFile = 0;\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\t// Copy the data\r\n\tCopyMemory((PVOID)pBuf, &stData, sizeof( stData ));\r\n\r\n\tUnmapViewOfFile(pBuf);\r\n\treturn TRUE;\r\n}\r\n```\r\n\r\n## What happens after Injecting to Remote process?\r\n\r\nNow we’re done with the main application. Now we can start analyzing the DLL being injected. It simply opens the shared memory and reads it into the shared structure which we discussed previously. See the code.\r\n\r\n```CPP\r\n// Function which reads and updates shared memory\r\nBOOL UpdateEnvVar()\r\n{\r\n\tHANDLE hMapFile = 0;\r\n\tSharedData* pShared = 0;\r\n\thMapFile = OpenFileMapping( FILE_MAP_READ, \r\n\t\tFALSE, SHAREMEM_NAME );   // name of mapping object \r\n\r\n\tif (hMapFile == NULL) \r\n\t{ \r\n\t\tOutputDebugString(TEXT(\"Could not open file mapping object\"));\r\n\t\treturn FALSE;\r\n\t} \r\n\r\n\tpShared = (SharedData*) MapViewOfFile(hMapFile, // handle to map object\r\n\t\tFILE_MAP_READ, 0, 0, sizeof( SharedData ));                   \r\n\r\n\tif (pShared == NULL) \r\n\t{ \r\n\t\tOutputDebugString(TEXT(\"Could not map view of file\")); \r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif( !pShared->bAddToExisting )\r\n\t{\r\n\t\tif( wcslen( pShared->strValue ))\r\n\t\t{\r\n\t\t\tSetEnvironmentVariableW( pShared->strVariable, \r\n\t\t\t\t\t\tpShared->strValue);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Delete variable\r\n\t\t\tSetEnvironmentVariableW( pShared->strVariable, NULL );\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get the required size\r\n\t\tconst DWORD dwReturn = GetEnvironmentVariable\r\n\t\t\t\t\t( pShared->strVariable, 0, 0 );\r\n\t\tconst DWORD dwErr = GetLastError();\r\n\r\n\t\tif( 0 ==  dwReturn && \r\n\t\t\tERROR_ENVVAR_NOT_FOUND == dwErr ) // Variable not found\r\n\t\t{\r\n\t\t\t// Set the new one\r\n\t\t\tSetEnvironmentVariableW( pShared->strVariable, \r\n\t\t\t\t\t\tpShared->strValue);\r\n\t\t}\r\n\t\telse if( dwReturn > 0 )\r\n\t\t{\r\n\t\t\tWCHAR* pstrExisting = new WCHAR[1024];\r\n\t\t\tif( 0 == GetEnvironmentVariable( pShared->strVariable, \r\n\t\t\t\tpstrExisting, dwReturn ) &&\r\n\t\t\t\tGetLastError() == 0 )\r\n\t\t\t{\r\n\t\t\t\tstd::wstring strNew( pstrExisting );\r\n\t\t\t\tstrNew += L\";\";\r\n\t\t\t\tstrNew += pShared->strValue;\r\n\t\t\t\tSetEnvironmentVariableW\r\n\t\t\t\t( pShared->strVariable, strNew.c_str());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tif( pShared )\r\n\t\tUnmapViewOfFile(pShared);\r\n\tif( hMapFile )\r\n\t\tCloseHandle(hMapFile);\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL APIENTRY DllMain( HMODULE hModule,\r\n\t\t     DWORD  ul_reason_for_call,\r\n\t\t     LPVOID lpReserved\r\n\t\t\t\t\t  )\r\n{\r\n\tswitch (ul_reason_for_call)\r\n\t{\r\n\tcase DLL_PROCESS_ATTACH:\r\n\t\t{\r\n\t\t\tTCHAR buff[MAX_PATH] = { 0 };\r\n\t\t\t_stprintf_s( buff, _T( \"Attached Process: %d\" ), \r\n\t\t\t\t\t\tGetCurrentProcessId());\r\n\t\t\tOutputDebugString( buff );\r\n\t\t\tUpdateEnvVar();\r\n\t\t}\r\n\r\n\tcase DLL_THREAD_ATTACH:\r\n\tcase DLL_THREAD_DETACH:\r\n\tcase DLL_PROCESS_DETACH:\r\n\t\tbreak;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n```\r\n\r\n## Limitations\r\nThe maximum length of variable that is supported is 1024 and the same number of characters for value.\r\n\r\n## How To Verify?\r\n\r\n* Use process explorer\r\n* My Other tool - Read Process Environment Variables\r\n* History\r\n\r\n30-Dec-2008 - Initial version\r\n\r\n\r\n### Authors and Contributors\r\nSarath C (@codereflect)\r\n\r\n### Support or Contact\r\ncsarath[at]gmail.com","tagline":"Dynamically Inject environment variables to Windows Processes","google":"UA-2191463-6","note":"Don't delete this file! It's used internally to help with page regeneration."}